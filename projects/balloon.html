<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Project: Balloon Betting Modeler</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --bg-color: #0a0a0a;
            --text-color: #fafafa;
            --accent-color: #4299e1;
            --border-color: #333;
            --font-main: 'JetBrains Mono', monospace;
        }

        body.light-mode {
            --bg-color: #fafafa;
            --text-color: #0a0a0a;
            --accent-color: #3182ce;
            --border-color: #ddd;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html { scroll-behavior: smooth; }
        html, body { min-height: 100%; }

        body {
            font-family: var(--font-main);
            font-size: 0.95rem;
            line-height: 1.6;
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: background-color 0.3s ease, color 0.3s ease;
            padding: 2rem;
        }

        .container {
            max-width: 70ch;
            margin: 0 auto;
        }

        .back-link {
            display: inline-block;
            color: var(--accent-color);
            text-decoration: none;
            margin-bottom: 2rem;
            transition: opacity 0.3s ease;
        }

        .back-link:hover { opacity: 0.7; }

        h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-size: 1.1rem;
            color: var(--accent-color);
            margin-bottom: 3rem;
        }

        h2 {
            font-size: 1.5rem;
            font-weight: 700;
            margin-top: 2.5rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 1px dashed var(--border-color);
        }

        p {
            margin-bottom: 1rem;
            opacity: 0.9;
        }

        .key-details {
            background: var(--border-color);
            padding: 1.5rem;
            border-radius: 0.25rem;
            margin: 2rem 0;
            border-left: 3px solid var(--accent-color);
        }
        
        .key-details p {
            margin-bottom: 0.5rem;
        }
        
        .key-details strong {
            color: var(--accent-color);
            margin-right: 0.5rem;
        }

        .timeline-container {
            margin: 2rem 0;
            padding: 1.5rem 0;
        }

        .timeline-track {
            position: relative;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 2rem;
        }

        .timeline-line {
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 2px;
            background: var(--border-color);
            z-index: 0;
        }

        .timeline-point {
            position: relative;
            z-index: 1;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
        }

        .timeline-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: var(--border-color);
            margin: 0 auto 0.5rem;
            transition: all 0.3s ease;
        }

        .timeline-point:hover .timeline-dot {
            background: var(--accent-color);
            transform: scale(1.3);
        }

        .timeline-point.active .timeline-dot {
            background: var(--accent-color);
            transform: scale(1.5);
            box-shadow: 0 0 0 3px rgba(66, 153, 225, 0.2);
        }

        .timeline-label {
            font-size: 0.75rem;
            opacity: 0.7;
            white-space: nowrap;
            transition: opacity 0.3s ease;
        }

        .timeline-point:hover .timeline-label,
        .timeline-point.active .timeline-label {
            opacity: 1;
            color: var(--accent-color);
        }

        .timeline-detail {
            display: none;
            padding: 1.5rem;
            background: var(--border-color);
            border-radius: 0.25rem;
            border-left: 3px solid var(--accent-color);
            margin-top: 1rem;
        }

        .timeline-detail.active {
            display: block;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .timeline-detail h4 {
            color: var(--accent-color);
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }

        .timeline-detail p {
            margin: 0;
            font-size: 0.9rem;
            opacity: 0.8;
        }

        .floating-theme-toggle {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            z-index: 1000;
            background: var(--border-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            width: 3rem;
            height: 3rem;
            border-radius: 50%;
            cursor: pointer;
            font-family: var(--font-main);
            transition: all 0.3s ease;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
        }

        .floating-theme-toggle:hover {
            background: var(--text-color);
            color: var(--bg-color);
            transform: scale(1.1);
        }

        .floating-theme-toggle svg { margin: 0; }

        @media (max-width: 600px) {
            .timeline-track { flex-wrap: wrap; gap: 1rem; }
            .timeline-line { display: none; }
            .timeline-point { flex: 0 0 calc(50% - 0.5rem); }
        }
    </style>
</head>
<body>

    <div class="container">
        <a href="index.html" class="back-link">‚Üê Back to Projects</a>
        
        <h1>Balloon Betting Modeler</h1>
        <p class="subtitle">
            A mathematical exercise in reshaping risk profiles using bonus value as a buffer
        </p>

        <h2>The Problem</h2>
        <p>
            The Martingale betting system is infamous for good reason. Double your bet after each loss, and eventually you'll recover everything. The problem is that "eventually" might mean betting what's left of your entire bankroll on a single hand. One bad streak wipes you out completely.
        </p>
        <p>
            Reverse Martingale flips the logic by doubling your bet after each win instead. This solves the bankroll explosion problem, but you're still gambling with your own money. Win five hands in a row and you've built a nice profit. Lose on the sixth and you've lost it all, plus you're still down your original stake. Each consecutive win roughly halves your probability of continuing the streak, so the math works against you quickly.
        </p>
        <p>
            Both systems have the same fundamental flaw: negative expected value. The house edge means that over enough attempts, losses are more likely than gains. You're playing with your own money, and the math is against you.
        </p>
        <p>
            But what if you could restructure the payoff entirely? What if the worst case was breaking even instead of losing money, while wins still compounded exponentially?
        </p>

        <h2>The Idea</h2>
        <p>
            The traditional bet modeler provides an "equilibrium" solution, one where the profit will be the same regardless of the outcome. Instead of just walking away with this secured profit, we can recalculate a new starting bet configuration that shifts all of the EV to one side. One outcome results in a profit (roughly double the profit of the equilibrium solution) and the other outcome results in breaking even (not a net loss).
        </p>
        <p>
            Even after winning the first round, the wagering requirements for the promotion will likely not be satisfied. Instead of satisfying these requirements in the traditional way, what if we continued to press our luck with one or more wagers? We could take the win amount from the first round and wager it again. If we win, then we have double that amount in profit while maintaining break-even as the worst case scenario.
        </p>
        <p>
            I called it Balloon Betting because that's exactly what it is. Each win inflates your profit. Each additional bet risks popping the balloon and sending you back to break-even. You inflate as far as you're willing to go, then stop. The probability of hitting a loss approaches 100% with each consecutive bet, so the tool calculates the exact safe bet size at every step.
        </p>

        <h2>Why Balloon?</h2>
        <p>
            The equilibrium strategy locks in a guaranteed profit. Balloon Betting asks: what if you could turn that guaranteed $50 into a potential $100, $200, $400, or more, without risking a loss?
        </p>
        <p>
            Each consecutive win doubles your profit potential. Win once and you have 2x the equilibrium profit. Win twice: 4x. Win three times: 8x. The exponential growth follows reverse Martingale logic, where each bet size increases based on your growing bankroll. The critical difference: when the balloon pops, you return to break-even instead of losing money.
        </p>
        <p>
            The trade-off is probability. Each consecutive win cuts your success odds roughly in half. Starting from about 49-50% for a single bet, your chances of three straight wins drop to around 12.5%. The tool shows you the declining probability at each step, letting you decide when the accumulated profit is worth locking in.
        </p>

        <h2>How It Works</h2>
        <p>
            The balloon bet calculation has three components. Adding these three values provides the maximum safe bet at each step:
        </p>
        <ol style="margin-left: 2rem; margin-bottom: 1rem;">
            <li style="margin-bottom: 0.5rem;">The profit from the initial equilibrium round. This is the actual cash profit you'd walk away with using the traditional hedged approach, not the bonus face value.</li>
            <li style="margin-bottom: 0.5rem;">The cash value of any lossback bonus you earned from the live dealer round, not always applicable.</li>
            <li style="margin-bottom: 0.5rem;">Something I call "wagering credit". Giving details of the calculation requires revealing proprietary information, but basically the more we wager ballooning, the less we will have to wager to unlock the bonus. This reduces the cost to cash out, so it can be included in the bet size calculation.</li>
        </ol>
        <p>
            The bet size calculation needs to be dynamic for two main reasons. First, the wagering credit calculation is complicated math that requires knowing the remaining wagering requirement at each point. Second, the payouts for a winning Player bet are 1:1 but a winning Banker bet pays 0.95:1. Both of these factors influence the safe bet size for the next round, so it's essential for the user to input their wagers as they go along.
        </p>

        <h2>UI Features</h2>
        <p>
            In addition to these bet size calculations, the tool also offers the option to enter a custom bet. This is useful for the case where the user wants to play side bets and for the case where the user made an error in placing the wager. For example, if the user only had time to place $75 instead of $80, they can enter that in the tool and have the correct results calculated for the next round.
        </p>
        <p>
            The tool supports both standard and "High Risk" modes. In High Risk mode, you're liable for your deposit on the first bet only. After that first round, all subsequent bets maintain the break-even floor. This allows for a larger initial balloon bet at the cost of actual downside risk on the opening hand.
        </p>
        <p>
            The tool will make a bet size recommendation until the wagering requirements have been met. Playing beyond that is probably unwise for players who receive frequent casino offers. That play would be best reserved for instances where they need to fulfill a wagering requirement. Mathematically, it would be possible to calculate a safe bet size forever until the player loses once. It's just not a recommended strategy, so it's not built into the software.
        </p>
        <p>
            A table of possible outcomes is displayed showing the range of possible results of winning <em>n</em> rounds, where n is the number of rounds required to fulfill the wagering requirement. The upper bound of profit for winning n rounds would be for the case of all Player wins and the lower bound of profit would be for all Banker wins. As the user enters their actual bet selections, these values converge to the real profit value.
        </p>
        <p>
            At every stage, the user has the option to consider: should I stop? Am I happy with this profit? Should I take the money and run or will I press my luck further? All of the visuals I implemented are to help the user make the most informed decision possible for these questions.
        </p>

        <div class="key-details">
            <p><strong>Stack:</strong> React, JavaScript (Hooks), Babel, Tailwind CSS</p>
            <p><strong>Core Concepts:</strong> Risk Profile Transformation, Sequential Wagering, Break-Even Calculation, Decision Tree Modeling</p>
            <p><strong>Status:</strong> Personal R&D (Unpublished)</p>
        </div>

        <h2>Development Evolution</h2>
        <div class="timeline-container">
            <div class="timeline-track">
                <div class="timeline-line"></div>
                
                <div class="timeline-point" data-version="0">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">Concept</div>
                </div>
                
                <div class="timeline-point" data-version="1">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">v1.0</div>
                </div>
                
                <div class="timeline-point" data-version="2">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">v1.5</div>
                </div>
                
                <div class="timeline-point" data-version="3">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">v1.6</div>
                </div>

                <div class="timeline-point" data-version="4">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">v2.0</div>
                </div>
                
                <div class="timeline-point" data-version="5">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">v2.10</div>
                </div>
                
                <div class="timeline-point" data-version="6">
                    <div class="timeline-dot"></div>
                    <div class="timeline-label">v2.19</div>
                </div>
            </div>

            <div class="timeline-detail" data-version="0">
                <h4>Concept Development</h4>
                <p>Built a spreadsheet to prove the concept. It worked, but the spreadsheet assumed all Player bets. That's fine for demonstrating the idea but useless in practice since you need to handle both outcomes dynamically.</p>
            </div>
            <div class="timeline-detail" data-version="1">
                <h4>Basic Implementation (v1.0)</h4>
                <p>Migrated to React so the calculator could recalculate the optimal bet size after each hand based on whether you chose Player or Banker. This solved the spreadsheet's limitation.</p>
            </div>
            <div class="timeline-detail" data-version="2">
                <h4>Custom Bet Feature (v1.5)</h4>
                <p>Added ability to place smaller bets than the "optimal" size if you want to maintain a safety buffer. Useful for accounting for side bets or just being more conservative.</p>
            </div>
            <div class="timeline-detail" data-version="3">
                <h4>Single Casino Mode (v1.6)</h4>
                <p>Added a "Single Casino" mode that didn't require cross-platform hedging. Also implemented "High Risk" mode where you're liable for your deposit on the first bet but break-even on all subsequent bets.</p>
            </div>
            <div class="timeline-detail" data-version="4">
                <h4>Dynamic Readouts (v2.0)</h4>
                <p>Added wagering progress bar and probability meter. Watching the probability get cut in half with each step makes the exponential risk very clear.</p>
            </div>
            <div class="timeline-detail" data-version="5">
                <h4>Profit Evolution Table (v2.10)</h4>
                <p>Built a table showing profit ranges that narrow as you progress. All-Player wins give you the ceiling, all-Banker wins give you the floor. The range converges as you play.</p>
            </div>
            <div class="timeline-detail" data-version="6">
                <h4>UI Polish (v2.19)</h4>
                <p>Polished the UI, added session management (reset, undo), made it responsive. This is production-ready for what it is.</p>
            </div>
        </div>

        <h2>Future Work</h2>
        <p>
            This tool is designed for Baccarat but the methodology is game-agnostic. It can work for any game with roughly 50/50 odds of doubling your money. This includes blackjack, red/black, even/odd, 1-18/19-36 bets on roulette, and Come/Don't Come or Pass/Don't Pass bets on craps. Future versions of the calculator would require slight tweaks to account for the rules of each game. For example, when using this tool with blackjack, it would be nice to have an option for winning with blackjack, which pays 3:2 instead of 1:1.
        </p>
        <p>
            I also developed this strategy into a similar one that doesn't require having a casino bonus at all. I call this one Moon Betting. This strategy has downside potential, meaning that it can result in a loss for the bettor, but it caps the downside to whatever the initial bet is. If the user is willing to stomach a small loss, they benefit from an enlarged first bet size, an effect that will compound exponentially if they are successful.
        </p>

    </div>

    <button id="floating-theme-toggle" class="floating-theme-toggle" title="Toggle dark/light mode">
        <svg id="theme-icon-sun" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
          <path d="M8 11a3 3 0 1 1 0-6 3 3 0 0 1 0 6zm0 1a4 4 0 1 0 0-8 4 4 0 0 0 0 8zM8 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 0zm0 13a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2A.5.5 0 0 1 8 13zm8-5a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2a.5.5 0 0 1 .5.5zM3 8a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1 0-1h2A.5.5 0 0 1 3 8zm10.657-5.657a.5.5 0 0 1 0 .707l-1.414 1.414a.5.5 0 1 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm-9.193 9.193a.5.5 0 0 1 0 .707L3.05 13.657a.5.5 0 0 1-.707-.707l1.414-1.414a.5.5 0 0 1 .707 0zm9.193 2.121a.5.5 0 0 1-.707 0l-1.414-1.414a.5.5 0 0 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707zM4.464 4.465a.5.5 0 0 1-.707 0L2.343 3.05a.5.5 0 1 1 .707-.707l1.414 1.414a.5.5 0 0 1 0 .707z"/>
        </svg>
        <svg id="theme-icon-moon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" style="display:none;">
          <path d="M6 .278a.768.768 0 0 1 .08.858 7.208 7.208 0 0 0-.878 3.46c0 4.021 3.278 7.277 7.318 7.277.527 0 1.04-.055 1.533-.16a.787.787 0 0 1 .81.316.733.733 0 0 1-.031.893A8.349 8.349 0 0 1 8.344 16C3.734 16 0 12.286 0 7.71 0 4.266 2.114 1.312 5.124.06A.752.752 0 0 1 6 .278zM4.858 1.311A7.269 7.269 0 0 0 1.025 7.71c0 4.021 3.278 7.277 7.318 7.277a7.316 7.316 0 0 0 5.205-2.149A8.507 8.507 0 0 1 8.344 15C4.234 15 1 11.766 1 7.71 1 5.25 2.414 3.05 4.858 1.311z"/>
        </svg>
    </button>

    <script>
        const themeToggle = document.getElementById('floating-theme-toggle'); 
        const body = document.body;
        const sunIcon = document.getElementById('theme-icon-sun');
        const moonIcon = document.getElementById('theme-icon-moon');

        function setTheme(theme) {
            if (theme === 'light') {
                body.classList.add('light-mode');
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
                localStorage.setItem('theme', 'light');
            } else {
                body.classList.remove('light-mode');
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
                localStorage.setItem('theme', 'dark');
            }
        }

        const savedTheme = localStorage.getItem('theme') || 'dark';
        setTheme(savedTheme);

        themeToggle.addEventListener('click', () => {
            const isLight = body.classList.contains('light-mode');
            setTheme(isLight ? 'dark' : 'light');
        });

        const timelinePoints = document.querySelectorAll('.timeline-point');
        const timelineDetails = document.querySelectorAll('.timeline-detail');

        timelinePoints.forEach(point => {
            point.addEventListener('click', () => {
                const version = point.getAttribute('data-version');
                
                timelinePoints.forEach(p => p.classList.remove('active'));
                timelineDetails.forEach(d => d.classList.remove('active'));
                
                point.classList.add('active');
                const detail = document.querySelector(`.timeline-detail[data-version="${version}"]`);
                if (detail) {
                    detail.classList.add('active');
                }
            });
        });
        
        document.addEventListener('DOMContentLoaded', () => {
            const firstPoint = document.querySelector('.timeline-point[data-version="0"]');
            if(firstPoint) {
                firstPoint.click();
            }
        });
    </script>

</body>
</html>
